git status
?setdiff
styler::style_pkg()
install.packages("styler")
library(styler)
styler::style_pkg()
gaussian()
binomial()
Gamma()
negative.binomial()
styler::style_pkg()
c(c(1), c(2), c(3))
c(c(1,2), c(2), c(3))
list(list(1),list(2),list(3))
list(list(1,2),list(2),list(3))
sapply(list(list(1),list(2),list(3)), function(x) x[[1]])
#'
#' @examples
#' example_function(1, 2)
#'
#' @importFrom package function
#' @importFrom package function
#' @importFrom package function
#'
#' Note: this is not a user facing function
#'
get_recommended_interventions_linear_cost <- function(beta_vec,
center_cha_coeff_vec = 0,
cost_coef,
x_min,
x_max,
goal,
center_cha = 0,
intercept = T,
phase="planning") {
if (length(center_cha) != length(center_cha_coeff_vec)) {
stop("center_cha_coeff_vec and center_cha are not at the same length")
}
if (intercept == T) {
beta0 <- beta_vec[1]
beta_vec <- beta_vec[-1]
} else {
beta0 <- 0
}
est_rec_int <- x_min
cost_effects <- beta_vec / cost_coef
# If all betas are non-positive the recommended intervention is x_min
if (all(cost_effects <= 0)) {
# TODO: notice the "expit", need to generalize to other inverse of link functions.
est_reachable_goal <- expit( beta0 + sum(center_cha_coeff_vec * center_cha) + sum(beta_vec * x_min) )
return(list(
est_rec_int = x_min,
goal = goal,
est_reachable_goal = est_reachable_goal
))
}
# If some betas are negative set their value in the
# estimated recommended intervention to x_min
neg_eff <- cost_effects <= 0
pos_eff <- cost_effects > 0
# Setting the baseline logit prob success by summing the intercept,
# the effect of center_cha, and the minimal values of the intervention
beta0.center <- beta0 + sum(center_cha_coeff_vec * center_cha) + sum(beta_vec[neg_eff] * x_min[neg_eff])
if (expit(beta0.center + sum(beta_vec[pos_eff] * x_min[pos_eff])) >= goal) {
return(list(est_rec_int = est_rec_int,
goal = goal,
est_reachable_goal = goal))
}
order.effect <- order(cost_effects[pos_eff], decreasing = T)
# Check if setting all positive effects to x_max can reach the goal
max.can.reach <- expit(beta0.center + sum(beta_vec[pos_eff] * x_max[pos_eff]))
if (max.can.reach < goal) {
# cannot reach the goal. check if phase = planning, if so, we try to get the
# reachable goal to be as close as possible to the actual goal.
if (phase == "planning") {
est_rec_int[pos_eff] <- x_max[pos_eff]
} else {
# Nevo et al web appendix section 5.1
# TODO: make this work for more than 2 intervention components?
for (c in 1:2) {
if (as.numeric(beta_vec[-c]) < 0) {
the.other.int <- x_min[-c]
} else {
the.other.int <- x_max[-c]
}
beta.max <- (logit(goal) - (sum(the.other.int * as.numeric(beta_vec[-c]) + beta0))) / x_max[c]
beta.min <- beta.max / 2
if (as.numeric(beta_vec[c]) < beta.min) {
est_rec_int[c] <- median(x_min[c], x_max[c])
} else {
slope <- (x_max[c] - median(x_min[c], x_max[c])) / (beta.max - beta.min)
est_rec_int[c] <- median(x_min[c], x_max[c]) + slope * (as.numeric(beta_vec[c]) - beta.min)
}
}
}
est_reachable_goal <- max.can.reach
} else {
# can reach the goal, so lets find the recommended interventions
est_reachable_goal <- goal
for (i in 1:max(order.effect)) {
# identify the 1 to i--th most cost effective betas
beta.temp <- beta_vec[pos_eff][order.effect][1:i]
# find upper bounds
x_max.temp <- x_max[pos_eff][order.effect][1:i]
if (i < length(order.effect)) {
beta.other.temp <- beta_vec[pos_eff][order.effect][(i + 1):length(order.effect)]
x.other.temp <- x_min[pos_eff][order.effect][(i + 1):length(order.effect)]
} else {
# if we are considering the last intervention component
beta.other.temp <- x.other.temp <- 0
}
# cannot reach the goal yet, move on to the next intervention component
if (expit(beta0.center + sum(beta.temp * x_max.temp) + sum(beta.other.temp * x.other.temp)) < goal) {
next
}
if (expit(beta0.center + sum(beta.temp * x_max.temp) + sum(beta.other.temp * x.other.temp)) == goal) {
est_rec_int[pos_eff][order.effect][1:i] <- x_max.temp
est_rec_int[pos_eff][order.effect][1:i] <- x_max.temp
break
}
if (i == 1) {
est_rec_int[pos_eff][order.effect][i] <- (logit(goal) - beta0.center - sum(x.other.temp * beta.other.temp)) / beta.temp[i]
break
} else {
est_rec_int[pos_eff][order.effect][1:(i - 1)] <- x_max.temp[-i]
# the top i-1 gets their maximal values
est_rec_int[pos_eff][order.effect][i] <- (logit(goal) - sum(beta.temp[1:(i - 1)] * x_max.temp[1:(i - 1)]) - beta0.center - sum(x.other.temp * beta.other.temp)) / beta.temp[i]
break
}
}
}
return(list(est_rec_int = est_rec_int, goal = goal, est_reachable_goal = est_reachable_goal))
}
intervention_lower_bounds <- c(0,0)
length(intervention_lower_bounds)
any(intervention_lower_bounds)
any(intervention_lower_bounds) < 0
intervention_lower_bounds
any(intervention_lower_bounds) > 0
any(intervention_lower_bounds) == 0
intervention_upper_bounds <- c(-1, 5)
which(intervention_upper_bounds < intervention_lower_bounds)
length(which(intervention_upper_bounds < intervention_lower_bounds))
coeff <- c(0.1, 0.3, 0.15)
cost_list_of_lists <- list(list(1),list(4))
cost_coeff <- sapply(cost_list_of_lists, function(x) x[[1]])
intervention_lower_bounds <- c(0,0)
intervention_upper_bounds <- c(10,20)
outcome_goal <- 0.8
get_recommended_interventions_linear_cost(coeff,
center_cha_coeff_vec = 0,
cost_coeff,
intervention_lower_bounds,
intervention_upper_bounds,
outcome_goal,
center_cha = 0,
intercept = T)
install.packages("rje")
library(rje)
get_recommended_interventions_linear_cost(coeff,
center_cha_coeff_vec = 0,
cost_coeff,
intervention_lower_bounds,
intervention_upper_bounds,
outcome_goal,
center_cha = 0,
intercept = T)
expit(4.287648*0.3 + 0.``)
expit(4.287648*0.3 + 0.1)
# get the recommended interventions that satisfy the outcome goal while minimizing the cost
rec_int_results <- get_recommended_interventions_linear_cost(coeff,
center_cha_coeff_vec = 0,
cost_coeff,
intervention_lower_bounds,
intervention_upper_bounds,
outcome_goal,
center_cha = 0,
intercept = T)
rec_int_cost <- rec_int_results$est_rec_int %*% cost_coeff
rec_int_cost
cost_coeff
coeff <- c(0.1, 0.1, 0.15, 0.2)
cost_list_of_lists <- list(list(1),list(4), list(2))
cost_coeff <- sapply(cost_list_of_lists, function(x) x[[1]])
intervention_lower_bounds <- c(0,0,0)
intervention_upper_bounds <- c(10,20,20)
outcome_goal <- 0.9
get_recommended_interventions_linear_cost(coeff,
center_cha_coeff_vec = 0,
cost_coeff,
intervention_lower_bounds,
intervention_upper_bounds,
outcome_goal,
center_cha = 0,
intercept = T)
coeff <- c(0.05, 0.1, 0.15, 0.2)
cost_list_of_lists <- list(list(1),list(4), list(2))
cost_coeff <- sapply(cost_list_of_lists, function(x) x[[1]])
intervention_lower_bounds <- c(0,0,0)
intervention_upper_bounds <- c(10,20,20)
outcome_goal <- 0.9
get_recommended_interventions_linear_cost(coeff,
center_cha_coeff_vec = 0,
cost_coeff,
intervention_lower_bounds,
intervention_upper_bounds,
outcome_goal,
center_cha = 0,
intercept = T)
coeff <- c(0.05, 0.1, 0.15, 0.2)
cost_list_of_lists <- list(list(1),list(4), list(2))
cost_coeff <- sapply(cost_list_of_lists, function(x) x[[1]])
intervention_lower_bounds <- c(0,0,0)
intervention_upper_bounds <- c(3,20,20)
outcome_goal <- 0.9
get_recommended_interventions_linear_cost(coeff,
center_cha_coeff_vec = 0,
cost_coeff,
intervention_lower_bounds,
intervention_upper_bounds,
outcome_goal,
center_cha = 0,
intercept = T)
coeff <- c(0.05, 0.1, 0.15, 0.2)
cost_list_of_lists <- list(list(1),list(4), list(2))
cost_coeff <- sapply(cost_list_of_lists, function(x) x[[1]])
intervention_lower_bounds <- c(0,0,0)
intervention_upper_bounds <- c(3,20,5)
outcome_goal <- 0.9
get_recommended_interventions_linear_cost(coeff,
center_cha_coeff_vec = 0,
cost_coeff,
intervention_lower_bounds,
intervention_upper_bounds,
outcome_goal,
center_cha = 0,
intercept = T)
0.1/1
0.15/4
0.2/2
coeff <- c(0.05, 0.1, 0.15, 0.2)
cost_list_of_lists <- list(list(1),list(4), list(2.2))
cost_coeff <- sapply(cost_list_of_lists, function(x) x[[1]])
intervention_lower_bounds <- c(0,0,0)
intervention_upper_bounds <- c(3,20,5)
outcome_goal <- 0.9
get_recommended_interventions_linear_cost(coeff,
center_cha_coeff_vec = 0,
cost_coeff,
intervention_lower_bounds,
intervention_upper_bounds,
outcome_goal,
center_cha = 0,
intercept = T)
0.2/2.2
0.15/4
c(1,2) * c(3,4)
document()
library(devtools)
document()
document()
document()
document()
check()
binomial()
document()
check()
document()
check()
data("mtcars")
summary(mtcars)
names(mtcars)
head(mtcars)
nchar("id")
mean(mtcars$vs)
document
document()
check()
check()
styler::style_pkg()
document()
check()
names(mtcars)
mtcars[[vs]]
data.frame(mtcars)
data.frame(mtcars)[[vs]]
testdf <- as.data.frame(mtcars)
testdf[["vs"]]
mtcars[['vs']]
check()
check()
check()
data("infert")
names(infert)
mean(infert$case)
summary(infert)
check()
load_all()
check()
document()
#'   intervention_lower_bounds = c(0, 0),
#'   intervention_upper_bounds = c(10, 20),
#'   outcome_goal = 0.8
#' )
#'
#' @importFrom rje expit logit
#' @import stats
#
# Note: no export, this is not a user facing function
#
get_recommended_interventions_linear_cost <- function(beta_vec,
cost_coef,
intervention_lower_bounds,
intervention_upper_bounds,
outcome_goal,
center_cha_coeff_vec = 0,
center_cha = 0,
intercept = T,
phase = "planning") {
# check if center_cha and center_cha_coeff_vec have the same length
if (length(center_cha) != length(center_cha_coeff_vec)) {
stop("coefficients for the center charactersitics and the number of given center characteristics are not at the same length.")
}
# handle intercept
if (intercept == T) {
beta0 <- beta_vec[1]
beta_vec <- beta_vec[-1]
} else {
beta0 <- 0
}
# Initialize estimated recommended intervention to minimum values
est_rec_int <- intervention_lower_bounds
# Calculate cost-effectiveness of each intervention
cost_effects <- beta_vec / cost_coef
# If all effects are non-positive, recommend minimum intervention
if (all(cost_effects <= 0)) {
# TODO: notice the "expit", need to generalize to other inverse of link functions.
est_reachable_outcome <- expit(beta0 + sum(center_cha_coeff_vec * center_cha) + sum(beta_vec * intervention_lower_bounds))
return(list(
est_rec_int = intervention_lower_bounds,
outcome_goal = outcome_goal,
est_reachable_outcome = est_reachable_outcome
))
}
# Separate positive and negative effects
neg_eff <- cost_effects <= 0
pos_eff <- cost_effects > 0
# Calculate baseline logit probability of success
beta0.center <- beta0 + sum(center_cha_coeff_vec * center_cha) + sum(beta_vec[neg_eff] * intervention_lower_bounds[neg_eff])
# Check if minimum intervention already reaches the outcome_goal
if (expit(beta0.center + sum(beta_vec[pos_eff] * intervention_lower_bounds[pos_eff])) >= outcome_goal) {
return(list(
est_rec_int = est_rec_int,
outcome_goal = outcome_goal,
est_reachable_outcome = outcome_goal
))
}
# Order positive effects by cost-effectiveness
order.effect <- order(cost_effects[pos_eff], decreasing = T)
# Check if maximum intervention can reach the outcome_goal
max.can.reach <- expit(beta0.center + sum(beta_vec[pos_eff] * intervention_upper_bounds[pos_eff]))
if (max.can.reach < outcome_goal) {
# cannot reach the outcome_goal. check if phase = planning, if so, we try to get the
# reachable outcome_goal to be as close as possible to the actual outcome_goal.
if (phase == "planning") {
est_rec_int[pos_eff] <- intervention_upper_bounds[pos_eff]
} else {
# Calculate intervention values for each component based on
# Nevo et al web appendix section 5.1
# TODO: generalize this to work with more than 2 intervention components
for (c in 1:2) {
if (as.numeric(beta_vec[-c]) < 0) {
the.other.int <- intervention_lower_bounds[-c]
} else {
the.other.int <- intervention_upper_bounds[-c]
}
beta.max <- (logit(outcome_goal) - (sum(the.other.int * as.numeric(beta_vec[-c]) + beta0))) / intervention_upper_bounds[c]
beta.min <- beta.max / 2
if (as.numeric(beta_vec[c]) < beta.min) {
est_rec_int[c] <- median(intervention_lower_bounds[c], intervention_upper_bounds[c])
} else {
slope <- (intervention_upper_bounds[c] - median(intervention_lower_bounds[c], intervention_upper_bounds[c])) / (beta.max - beta.min)
est_rec_int[c] <- median(intervention_lower_bounds[c], intervention_upper_bounds[c]) + slope * (as.numeric(beta_vec[c]) - beta.min)
}
}
}
est_reachable_outcome <- max.can.reach
} else {
# can reach the outcome_goal, find the recommended interventions
est_reachable_outcome <- outcome_goal
# Iterate through interventions in order of cost-effectiveness
# It checks if the most cost-effective intervention alone can reach the outcome_goal
# If not, it adds the next most cost-effective intervention to the mix
# This process continues until it finds a combination that can reach the outcome_goal
for (i in 1:max(order.effect)) {
beta.temp <- beta_vec[pos_eff][order.effect][1:i]
intervention_upper_bounds.temp <- intervention_upper_bounds[pos_eff][order.effect][1:i]
if (i < length(order.effect)) {
beta.other.temp <- beta_vec[pos_eff][order.effect][(i + 1):length(order.effect)]
x.other.temp <- intervention_lower_bounds[pos_eff][order.effect][(i + 1):length(order.effect)]
} else {
# if we are considering the last intervention component
beta.other.temp <- x.other.temp <- 0
}
# Check if current set of interventions can reach the outcome_goal
if (expit(beta0.center + sum(beta.temp * intervention_upper_bounds.temp) + sum(beta.other.temp * x.other.temp)) < outcome_goal) {
next
}
# If the outcome_goal is exactly reached with all considered interventions at their maximum
if (expit(beta0.center + sum(beta.temp * intervention_upper_bounds.temp) + sum(beta.other.temp * x.other.temp)) == outcome_goal) {
est_rec_int[pos_eff][order.effect][1:i] <- intervention_upper_bounds.temp
est_rec_int[pos_eff][order.effect][1:i] <- intervention_upper_bounds.temp
break
}
# The outcome_goal can be reached, we calculate the recommended intervention levels
# If only one intervention is needed
if (i == 1) {
est_rec_int[pos_eff][order.effect][i] <- (logit(outcome_goal) - beta0.center - sum(x.other.temp * beta.other.temp)) / beta.temp[i]
break
} else {
# multiple interventions are needed
est_rec_int[pos_eff][order.effect][1:(i - 1)] <- intervention_upper_bounds.temp[-i]
# the top i-1 gets their maximal values
est_rec_int[pos_eff][order.effect][i] <- (logit(outcome_goal) - sum(beta.temp[1:(i - 1)] * intervention_upper_bounds.temp[1:(i - 1)]) - beta0.center - sum(x.other.temp * beta.other.temp)) / beta.temp[i]
break
}
}
}
return(list(
est_rec_int = est_rec_int,
outcome_goal = outcome_goal,
est_reachable_outcome = est_reachable_outcome
))
}
get_recommended_interventions_linear_cost(
beta_vec = c(0.1, 0.3, 0.15),
cost_coef = c(1, 4),
intervention_lower_bounds = c(0, 0),
intervention_upper_bounds = c(10, 20),
outcome_goal = 0.8
)
document()
check()
build()
install()
library(LAGO)
document()
check()
document()
check()
document()
rm(list = c("get_recommended_interventions_linear_cost"))
document()
check()
styler::style_pkg()
document()
check()
load("~/Desktop/all_BB_data.RData")
View(all.BB.data)
# Load functions
#source('/Users/danielnevo/Dropbox/LAGO/LAGO_R/BetterBirthR/AuxFunc.R', echo=F)
#source('/Users/danielnevo/Dropbox/LAGO/LAGO_R/Sims/2019R1/Functions/OptInterLinGeneral.R', echo=TRUE)
#### Load data ####
setwd("C:/Users/abing/Dropbox/Research stuff/Judith Lok/2021 Spring/LAGO examples for continuous case/BetterBirth study")
usethis::use_package_doc()
document()
document()
document()
BB_data <- readRDS("data/BB_data.rds")
usethis::use_data(BB_data, overwrite = TRUE)
document()
check()
document()
usethis::use_data(BB_data, overwrite = TRUE)
usethis::use_package_doc()
document()
devtools::document()
clean_dll()
document()
View(BB_data)
usethis::use_data(BB_data, overwrite = TRUE)
document()
list.files("data")
list.files("R")
devtools::clean_dll()
devtools::load_all(reset = TRUE)
devtools::document()
devtools::clean_dll()
devtools::load_all(reset = TRUE)
devtools::document()
check()
document()
pkgload::dev_help('BB_data')
install()
document()
document()
styler::style_pkg()
document()
check()
build()
install()
library(LAGO)
devtools::clean_dll()
devtools::document()
devtools::build()
install()
library(LAGO)
unlink("/Users/antebing/Library/Caches/org.R-project.R/R/renv/library/LAGO-130a3f46", recursive = TRUE)
build()
check()
install.packages("renv")
renv::restore()
