}
# check if outcome name is one of the columns in the data frame
if (!(outcome_name %in% names(df))) {
stop("The outcome name is not present in the provided data frame.")
}
# check if the outcome type is a character type
if (!is.character(outcome_type)) {
stop("The outcome type is not a character type.")
}
# check if the outcome type is either continuous or binary
allowed_outcome_types <- c("continuous", "binary")
if (!(outcome_type %in% allowed_outcome_types)) {
stop(paste("Outcome type", outcome_type, "is not 'continuous' or 'binary'."))
}
# check if the glm family is a character type
if (!is.character(glm_family)) {
stop("The glm family is not a character type.")
}
# TODO: for later versions, check if the user provided glm_family is one of
# the supported family names. For v1, we are only considering binomial family.
# check if interventions_list is a character vector type
if (!(is.vector(interventions_list) && is.character(interventions_list))) {
stop("Interventions list must be a character vector.")
}
# check if interventions_list are all columns in the data frame
if (!all(interventions_list %in% names(df))) {
stop("All elements in interventions_list must be columns in the data frame.")
}
# check if center_characteristic_list is a character vector type
if (!is.null(center_characteristic_list)) {
if (!(is.vector(center_characteristic_list) && is.character(center_characteristic_list))) {
stop("center_characteristic_list must be a character vector.")
}
# check if interventions_list are all columns in the data frame
if (!all(center_characteristic_list %in% names(df))) {
stop("All elements in center_characteristic_list must be columns in the data frame.")
}
# check if center_characteristic_list_for_optimization is a numeric vector type
if (!(is.vector(center_characteristic_list_for_optimization) && is.numeric(center_characteristic_list_for_optimization))) {
stop("center_characteristic_list_for_optimization must be a numeric vector.")
}
# check if center_characteristic_list_for_optimization is not null
if (is.null(center_characteristic_list_for_optimization)) {
stop("center_characteristic_list_for_optimization is NULL. You decided to
include center characteristics in the model, please either provide
values of the center characteristics for LAGO optimization, or consider
dropping the center characteristics.")
}
# check if length of center_characteristic_list_for_optimization is the same
# as the length of center_characteristic_list
if (length(center_characteristic_list) != length(center_characteristic_list_for_optimization)) {
stop("The length of center_characteristic_list does not equal to the length of
center_characteristic_list_for_optimization.")
}
}
# if (!is.list(interventions_list) || !all(sapply(
#   interventions_list,
#   is.character
# ))) {
#   stop("interventions_list must be a list of strings")
# }
# # check if interventions_list are all columns in the data frame
# if (!all(unlist(interventions_list) %in% names(df))) {
#   stop("All elements in the interventions_list must be column names in the provided data frame.")
# }
# If center characteristic list is provided, check if it is in the data frame
# if (!is.null(center_characteristic_list)) {
#   if (!is.list(center_characteristic_list) || !all(sapply(
#     center_characteristic_list,
#     is.character
#   ))) {
#     stop("center_characteristic_list must be a list of strings")
#   }
#   # check if center_characteristic_list are all columns in the data frame
#   if (!all(unlist(center_characteristic_list) %in% names(df))) {
#     stop("All elements in the center_characteristic_list must be column names in the provided data frame.")
#   }
# }
# check if intervention_lower_bounds and intervention_upper_bounds are both
# numerical vectors
if ( !(is.vector(intervention_lower_bounds) && is.numeric(intervention_lower_bounds)) ) {
stop("intervention_lower_bounds is not a numeric vector.")
}
if ( !(is.vector(intervention_upper_bounds) && is.numeric(intervention_upper_bounds)) ) {
stop("intervention_upper_bounds is not a numeric vector.")
}
# check if lower bounds list and upper bounds list have the same length,
# and if the lower bounds are <= upper bounds respectively
if (length(intervention_lower_bounds) != length(intervention_upper_bounds)) {
stop("The lengths of lower and upper bounds do not match.")
}
if (any(intervention_lower_bounds < 0)) {
stop("The intervention must have non-negative values only.")
}
invalid_indices <- which(intervention_upper_bounds < intervention_lower_bounds)
if (length(invalid_indices) > 0) {
stop(paste(
"Invalid bounds at position(s):",
paste(invalid_indices, collapse = ", "),
"\nUpper bounds for the interventions must be greater than or equal to the lower bounds."
))
}
# check if cost_list_of_lists is a list, and each list within the list is a numeric vector
if (!is.list(cost_list_of_lists)) {
stop("cost_list_of_lists must be a list.")
}
# Check if all elements of cost_list_of_lists are lists
if (!all(sapply(cost_list_of_lists, is.list))) {
stop("All elements of the cost_list_of_lists must be lists.")
}
# Check if all sub-elements of cost_list_of_lists are numeric
all_numeric <- all(sapply(cost_list_of_lists, function(sublist) {
all(sapply(sublist, is.numeric))
}))
if (!all_numeric) {
stop("All elements in the sublists of cost_list_of_lists must be numeric.")
}
# check if the dimension of cost_list_of_lists matches the dimension of interventions_list
if (length(cost_list_of_lists) != length(interventions_list)) {
stop("The lengths of cost_list_of_lists and interventions_list do not match.")
}
# check if the outcome goal optimization method is a character type
if (!is.character(outcome_goal_optimization)) {
stop("The outcome_goal_optimization is not a character type.")
}
# V1 does not consider the value of outcome_goal_optimization, because we are
# only working with linear cost functions for now. For linear cost functions,
# we have a very robust and fast way of solving for recommended interventions,
# which maximizes the most cost-effective intervention component first, if the
# outcome goal is not met, we max out the second most cost-effective intervention
# component, and so on, until the outcome goal is achieved.
#
# See get_recommended_intervention_linear_cost.R for details.
#
# TODO: future versions will consider both 'numerical' and 'grid_search'
# Previously, we only had grid search method for working with cubic cost
# function. For PULESA analysis, Jingyu added the numerical solution. Check
# the dropbox folder 'LAGO r package paper' for Jingyu's code.
# check if the outcome goal is a numeric number
if (!is.numeric(outcome_goal)) {
stop("The outcome goal is not numeric.")
}
# check if the outcome goal >= outcome that we already observed
if (outcome_goal <= mean(df[[outcome_name]])) {
stop("The outcome goal is smaller than the intervention group mean, please increase the outcome goal.")
}
# Convert glm family strings to actual glm family objects
# need this step before fitting the models.
# TODO: figure out which ones do we want to support?
# for v1, we are only working with binomial family.
family_object <- switch(glm_family,
"binomial" = binomial(),
"poisson" = poisson(),
"gaussian" = gaussian(),
"Gamma" = Gamma(),
"inverse.gaussian" = inverse.gaussian(),
"quasi" = quasi(),
"quasibinomial" = quasibinomial(),
"quasipoisson" = quasipoisson(),
stop("Unsupported family. Please use one of the supported family types.")
)
# fit the model
# depending on the whether the user wants to include center characteristics
# we fit the model differently.
if (is.null(center_characteristic_list)) {
formula <- as.formula(paste(outcome_name, "~", paste(interventions_list, collapse = " + ")))
model <- glm(formula, data = df, family = family_object)
} else {
formula_with_center_characteristics <- as.formula(paste(outcome_name, "~", paste(interventions_list, collapse = " + "), " + ", paste(center_characteristic_list, collapse = " + ")))
model <- glm(formula_with_center_characteristics, data = df, family = family_object)
}
# if model did not converge, no need to continue to calculate the recommended
# interventions.
if (!model$converged) {
stop("Model did not converge. Please check your data and model specifications.")
}
# get coefficients for the intervention components
if (include_intercept == TRUE) {
int_coeff <- model$coefficients[c('(Intercept)', interventions_list)]
} else {
int_coeff <- model$coefficients[interventions_list]
}
# get coefficients for the center characteristics
if (!is.null(center_characteristic_list)) {
center_characteristics_coeff <- model$coefficients[center_characteristic_list]
}
# TODO: add the option for non linear cost functions
# for v1, we are only supporting linear cost functions, so below, I'm using
# x[[1]], but this will need to be updated for other types of cost functions.
cost_coef <- sapply(cost_list_of_lists, function(x) x[[1]])
# set the values of center_cha_coeff_vec and center_cha based on if
# center_characteristic_list is defined. See parameter definitions in function
# get_recommended_interventions_linear_cost for details.
if (!is.null(center_characteristic_list)) {
center_cha_coeff_vec <- center_characteristics_coeff
center_cha <- center_characteristic_list_for_optimization
} else {
center_cha_coeff_vec <- 0
center_cha <- 0
}
# get the recommended interventions that satisfy the outcome goal while
# minimizing the total cost.
# TODO: add support for the "phase" option, the phase option is used to indicate
# if we are calculating the recommended interventions for the next stage, or
# calculating the optimal interventions at the end of the LAGO trial. For the
# optimal intervention at the end of the LAGO trial, using linear cost
# functions, see web appendix section 5.1 of Nevo et al for details.
rec_int_results <- get_recommended_interventions_linear_cost(
beta_vec = int_coeff,
center_cha_coeff_vec = center_cha_coeff_vec,
cost_coef = cost_coef,
intervention_lower_bounds = intervention_lower_bounds,
intervention_upper_bounds = intervention_upper_bounds,
outcome_goal = outcome_goal,
center_cha = center_cha,
intercept = include_intercept
)
rec_int <- rec_int_results$est_rec_int
rec_int_cost <- rec_int %*% cost_coef
est_outcome_goal <- rec_int_results$est_reachable_outcome
# TODO: add confidence set calculations for the recommended interventions
# for v1, we are only returning the following list:
return(list(
rec_int,
rec_int_cost,
est_outcome_goal
))
}
optimization_results <- calculate_recommended_interventions(
df = BB_data,
outcome_name = "pp3_oxytocin_mother",
outcome_type = "binary",
glm_family = "binomial",
interventions_list = c("coaching_updt", "launch_duration"),
center_characteristic_list = c("birth_volume_100"),
center_characteristic_list_for_optimization = 1.75,
intervention_lower_bounds = c(0,0),
intervention_upper_bounds = c(40, 5),
cost_list_of_lists = list(list(1.7), list(8)),
outcome_goal = 0.85)
#'   intervention_upper_bounds = c(10, 20),
#'   outcome_goal = 0.8
#' )
#'
#' @importFrom rje expit logit
#' @import stats
#'
#' @export
#
#
get_recommended_interventions_linear_cost <- function(beta_vec,
cost_coef,
intervention_lower_bounds,
intervention_upper_bounds,
outcome_goal,
center_cha_coeff_vec = 0,
center_cha = 0,
intercept = TRUE,
phase = "planning") {
# check if center_cha and center_cha_coeff_vec have the same length
if (length(center_cha) != length(center_cha_coeff_vec)) {
stop("coefficients for the center charactersitics and the number of given center characteristics are not at the same length.")
}
# handle intercept
if (intercept == T) {
beta0 <- beta_vec[1]
beta_vec <- beta_vec[-1]
} else {
beta0 <- 0
}
# Initialize estimated recommended intervention to minimum values
est_rec_int <- intervention_lower_bounds
# Calculate cost-effectiveness of each intervention
cost_effects <- beta_vec / cost_coef
# If all effects are non-positive, recommend minimum intervention
if (all(cost_effects <= 0)) {
# TODO: notice the "expit", need to generalize to other inverse of link functions.
est_reachable_outcome <- expit(beta0 + sum(center_cha_coeff_vec * center_cha) + sum(beta_vec * intervention_lower_bounds))
return(list(
est_rec_int = intervention_lower_bounds,
outcome_goal = outcome_goal,
est_reachable_outcome = est_reachable_outcome
))
}
# Separate positive and negative effects
neg_eff <- cost_effects <= 0
pos_eff <- cost_effects > 0
# Calculate baseline logit probability of success
beta0.center <- beta0 + sum(center_cha_coeff_vec * center_cha) + sum(beta_vec[neg_eff] * intervention_lower_bounds[neg_eff])
# Check if minimum intervention already reaches the outcome_goal
if (expit(beta0.center + sum(beta_vec[pos_eff] * intervention_lower_bounds[pos_eff])) >= outcome_goal) {
return(list(
est_rec_int = est_rec_int,
outcome_goal = outcome_goal,
est_reachable_outcome = outcome_goal
))
}
# Order positive effects by cost-effectiveness
order.effect <- order(cost_effects[pos_eff], decreasing = T)
# Check if maximum intervention can reach the outcome_goal
max.can.reach <- as.numeric(expit(beta0.center + sum(beta_vec[pos_eff] * intervention_upper_bounds[pos_eff])))
if (max.can.reach < outcome_goal) {
# cannot reach the outcome_goal. check if phase = planning, if so, we try to get the
# reachable outcome_goal to be as close as possible to the actual outcome_goal.
if (phase == "planning") {
est_rec_int[pos_eff] <- intervention_upper_bounds[pos_eff]
} else {
# Calculate intervention values for each component based on
# Nevo et al web appendix section 5.1
# TODO: generalize this to work with more than 2 intervention components
for (c in 1:2) {
if (as.numeric(beta_vec[-c]) < 0) {
the.other.int <- intervention_lower_bounds[-c]
} else {
the.other.int <- intervention_upper_bounds[-c]
}
beta.max <- (logit(outcome_goal) - (sum(the.other.int * as.numeric(beta_vec[-c]) + beta0))) / intervention_upper_bounds[c]
beta.min <- beta.max / 2
if (as.numeric(beta_vec[c]) < beta.min) {
est_rec_int[c] <- median(intervention_lower_bounds[c], intervention_upper_bounds[c])
} else {
slope <- (intervention_upper_bounds[c] - median(intervention_lower_bounds[c], intervention_upper_bounds[c])) / (beta.max - beta.min)
est_rec_int[c] <- median(intervention_lower_bounds[c], intervention_upper_bounds[c]) + slope * (as.numeric(beta_vec[c]) - beta.min)
}
}
}
est_reachable_outcome <- max.can.reach
} else {
# can reach the outcome_goal, find the recommended interventions
est_reachable_outcome <- outcome_goal
# Iterate through interventions in order of cost-effectiveness
# It checks if the most cost-effective intervention alone can reach the outcome_goal
# If not, it adds the next most cost-effective intervention to the mix
# This process continues until it finds a combination that can reach the outcome_goal
for (i in 1:max(order.effect)) {
beta.temp <- beta_vec[pos_eff][order.effect][1:i]
intervention_upper_bounds.temp <- intervention_upper_bounds[pos_eff][order.effect][1:i]
if (i < length(order.effect)) {
beta.other.temp <- beta_vec[pos_eff][order.effect][(i + 1):length(order.effect)]
x.other.temp <- intervention_lower_bounds[pos_eff][order.effect][(i + 1):length(order.effect)]
} else {
# if we are considering the last intervention component
beta.other.temp <- x.other.temp <- 0
}
# Check if current set of interventions can reach the outcome_goal
if (expit(beta0.center + sum(beta.temp * intervention_upper_bounds.temp) + sum(beta.other.temp * x.other.temp)) < outcome_goal) {
next
}
# If the outcome_goal is exactly reached with all considered interventions at their maximum
if (expit(beta0.center + sum(beta.temp * intervention_upper_bounds.temp) + sum(beta.other.temp * x.other.temp)) == outcome_goal) {
est_rec_int[pos_eff][order.effect][1:i] <- intervention_upper_bounds.temp
est_rec_int[pos_eff][order.effect][1:i] <- intervention_upper_bounds.temp
break
}
# The outcome_goal can be reached, we calculate the recommended intervention levels
# If only one intervention is needed
if (i == 1) {
est_rec_int[pos_eff][order.effect][i] <- (logit(outcome_goal) - beta0.center - sum(x.other.temp * beta.other.temp)) / beta.temp[i]
break
} else {
# multiple interventions are needed
est_rec_int[pos_eff][order.effect][1:(i - 1)] <- intervention_upper_bounds.temp[-i]
# the top i-1 gets their maximal values
est_rec_int[pos_eff][order.effect][i] <- (logit(outcome_goal) - sum(beta.temp[1:(i - 1)] * intervention_upper_bounds.temp[1:(i - 1)]) - beta0.center - sum(x.other.temp * beta.other.temp)) / beta.temp[i]
break
}
}
}
return(list(
est_rec_int = est_rec_int,
outcome_goal = outcome_goal,
est_reachable_outcome = est_reachable_outcome
))
}
optimization_results <- calculate_recommended_interventions(
df = BB_data,
outcome_name = "pp3_oxytocin_mother",
outcome_type = "binary",
glm_family = "binomial",
interventions_list = c("coaching_updt", "launch_duration"),
center_characteristic_list = c("birth_volume_100"),
center_characteristic_list_for_optimization = 1.75,
intervention_lower_bounds = c(0,0),
intervention_upper_bounds = c(40, 5),
cost_list_of_lists = list(list(1.7), list(8)),
outcome_goal = 0.85)
document()
devtools::clean_and_rebuild()
clean_dll()
build()
install()
remove.packages("LAGO")
clean_dll()
calculate_recommended_interventions
build()
devtools::build()
devtools::install
devtools::install()
devtools::load_all()
rm(list = c("calculate_recommended_interventions",
"get_recommended_interventions_linear_cost"))
devtools::load_all()
test()
devtools::test()
# your path to the package tar.gz file
# install.packages("path/to/LAGO_0.1.0.tar.gz", repos = NULL, type = "source")
library(LAGO)
# BB data has been open sourced, so I pre-loaded the BB data in the LAGO package
BB_data <- LAGO::BB_data
head(BB_data)
# Real use case. We expect this to be the user experience when
# using this R package.
optimization_results <- calculate_recommended_interventions(
df = BB_data,
outcome_name = "pp3_oxytocin_mother",
outcome_type = "binary",
glm_family = "binomial",
interventions_list = c("coaching_updt", "launch_duration"),
center_characteristic_list = c("birth_volume_100"),
center_characteristic_list_for_optimization = 1.75,
intervention_lower_bounds = c(0,0),
intervention_upper_bounds = c(40, 5),
cost_list_of_lists = list(list(1.7), list(8)),
outcome_goal = 0.85)
optimization_results
# Real use case. We expect this to be the user experience when
# using this R package.
optimization_results <- calculate_recommended_interventions(
df = BB_data,
outcome_name = "pp3_oxytocin_mother",
outcome_type = "binary",
glm_family = "binomial",
interventions_list = c("coaching_updt", "launch_duration"),
center_characteristic_list = c("birth_volume_100"),
center_characteristic_list_for_optimization = 1.75,
intervention_lower_bounds = c(1,1),
intervention_upper_bounds = c(40, 5),
cost_list_of_lists = list(list(1.7), list(8)),
outcome_goal = 0.85)
optimization_results
# From Nevo et al paper:
# "... we estimated the optimal intervention for a center with average
# birth volumn (z=175) to be a launch duration of 2.78 days and 1 coaching visit."
optimization_results$est_reachable_outcome
calculate_recommended_interventions(
df = BB_data,
outcome_name = "pp3_oxytocin_mother",
outcome_type = "binary",
glm_family = "binomial",
interventions_list = c("coaching_updt", "launch_duration"),
center_characteristic_list = c("birth_volume_100"),
center_characteristic_list_for_optimization = 1.75,
intervention_lower_bounds = c(1,1),
intervention_upper_bounds = c(40, 5),
cost_list_of_lists = list(list(1.7), list(8)),
outcome_goal = 0.85)
devtools::load_all()
# Real use case. We expect this to be the user experience when
# using this R package.
optimization_results <- calculate_recommended_interventions(
df = BB_data,
outcome_name = "pp3_oxytocin_mother",
outcome_type = "binary",
glm_family = "binomial",
interventions_list = c("coaching_updt", "launch_duration"),
center_characteristic_list = c("birth_volume_100"),
center_characteristic_list_for_optimization = 1.75,
intervention_lower_bounds = c(1,1),
intervention_upper_bounds = c(40, 5),
cost_list_of_lists = list(list(1.7), list(8)),
outcome_goal = 0.85)
# From Nevo et al paper:
# "... we estimated the optimal intervention for a center with average
# birth volumn (z=175) to be a launch duration of 2.78 days and 1 coaching visit."
optimization_results$est_reachable_outcome
calculate_recommended_interventions(
df = BB_data,
outcome_name = "pp3_oxytocin_mother",
outcome_type = "binary",
glm_family = "binomial",
interventions_list = c("coaching_updt", "launch_duration"),
center_characteristic_list = c("birth_volume_100"),
center_characteristic_list_for_optimization = 1.75,
intervention_lower_bounds = c(1,1),
intervention_upper_bounds = c(40, 5),
cost_list_of_lists = list(list(1.7), list(8)),
outcome_goal = 0.85)
# From Nevo et al paper:
# "... we estimated the optimal intervention for a center with average
# birth volumn (z=175) to be a launch duration of 2.78 days and 1 coaching visit."
optimization_results$rec_int
# cost for the recommended interventions
optimization_results$rec_int_cost
document()
devtools::document()
devtools::check()
devtools::build()
devtools::install()
document()
devtools::document()
devtools::check()
devtools::build()
devtools::install()
devtools::document
devtools::document()
devtools::check()
devtools::build()
devtools::install()
devtools::document()
devtools::check()
devtools::build()
devtools::install()
